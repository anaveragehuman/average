diff --git a/bin/internal/shared.sh b/bin/internal/shared.sh
index 3532c23114..afb1c07d6c 100644
--- a/bin/internal/shared.sh
+++ b/bin/internal/shared.sh
@@ -3,7 +3,6 @@
 # Use of this source code is governed by a BSD-style license that can be
 # found in the LICENSE file.
 
-
 # ---------------------------------- NOTE ---------------------------------- #
 #
 # Please keep the logic in this file consistent with the logic in the
@@ -18,37 +17,37 @@ set -e
 unset CDPATH
 
 function pub_upgrade_with_retry {
-  local total_tries="10"
-  local remaining_tries=$((total_tries - 1))
-  while [[ "$remaining_tries" -gt 0 ]]; do
-    (cd "$FLUTTER_TOOLS_DIR" && "$DART" pub upgrade --suppress-analytics) && break
-    >&2 echo "Error: Unable to 'pub upgrade' flutter tool. Retrying in five seconds... ($remaining_tries tries left)"
-    remaining_tries=$((remaining_tries - 1))
-    sleep 5
-  done
-
-  if [[ "$remaining_tries" == 0 ]]; then
-    >&2 echo "Command 'pub upgrade' still failed after $total_tries tries, giving up."
-    return 1
-  fi
-  return 0
+	local total_tries="10"
+	local remaining_tries=$((total_tries - 1))
+	while [[ "$remaining_tries" -gt 0 ]]; do
+		(cd "$FLUTTER_TOOLS_DIR" && "$DART" pub upgrade --suppress-analytics) && break
+		echo >&2 "Error: Unable to 'pub upgrade' flutter tool. Retrying in five seconds... ($remaining_tries tries left)"
+		remaining_tries=$((remaining_tries - 1))
+		sleep 5
+	done
+
+	if [[ "$remaining_tries" == 0 ]]; then
+		echo >&2 "Command 'pub upgrade' still failed after $total_tries tries, giving up."
+		return 1
+	fi
+	return 0
 }
 
 # Trap function for removing any remaining lock file at exit.
-function _rmlock () {
-  [ -n "$FLUTTER_UPGRADE_LOCK" ] && rm -rf "$FLUTTER_UPGRADE_LOCK"
+function _rmlock() {
+	[ -n "$FLUTTER_UPGRADE_LOCK" ] && rm -rf "$FLUTTER_UPGRADE_LOCK"
 }
 
 # Determines which lock method to use, based on what is available on the system.
 # Returns a non-zero value if the lock was not acquired, zero if acquired.
-function _lock () {
-  if hash flock 2>/dev/null; then
-    flock --nonblock --exclusive 7 2>/dev/null
-  elif hash shlock 2>/dev/null; then
-    shlock -f "$1" -p $$
-  else
-    mkdir "$1" 2>/dev/null
-  fi
+function _lock() {
+	if hash flock 2>/dev/null; then
+		flock --nonblock --exclusive 7 2>/dev/null
+	elif hash shlock 2>/dev/null; then
+		shlock -f "$1" -p $$
+	else
+		mkdir "$1" 2>/dev/null
+	fi
 }
 
 # Waits for an update lock to be acquired.
@@ -86,164 +85,155 @@ function _lock () {
 # A flock lock is released when this subshell exits and file descriptor 7 is
 # closed. The mkdir lock is released via an exit trap from the subshell that
 # deletes the lock directory.
-function _wait_for_lock () {
-  FLUTTER_UPGRADE_LOCK="$FLUTTER_ROOT/bin/cache/.upgrade_lock"
-  local waiting_message_displayed
-  while ! _lock "$FLUTTER_UPGRADE_LOCK"; do
-    if [[ -z $waiting_message_displayed ]]; then
-      # Print with a return so that if the Dart code also prints this message
-      # when it does its own lock, the message won't appear twice. Be sure that
-      # the clearing printf below has the same number of space characters.
-      printf "Waiting for another flutter command to release the startup lock...\r" >&2;
-      waiting_message_displayed="true"
-    fi
-    sleep .1;
-  done
-  if [[ $waiting_message_displayed == "true" ]]; then
-    # Clear the waiting message so it doesn't overlap any following text.
-    printf "                                                                  \r" >&2;
-  fi
-  unset waiting_message_displayed
-  # If the lock file is acquired, make sure that it is removed on exit.
-  trap _rmlock INT TERM EXIT
+function _wait_for_lock() {
+	FLUTTER_UPGRADE_LOCK="$FLUTTER_ROOT/bin/cache/.upgrade_lock"
+	local waiting_message_displayed
+	while ! _lock "$FLUTTER_UPGRADE_LOCK"; do
+		if [[ -z $waiting_message_displayed ]]; then
+			# Print with a return so that if the Dart code also prints this message
+			# when it does its own lock, the message won't appear twice. Be sure that
+			# the clearing printf below has the same number of space characters.
+			printf "Waiting for another flutter command to release the startup lock...\r" >&2
+			waiting_message_displayed="true"
+		fi
+		sleep .1
+	done
+	if [[ $waiting_message_displayed == "true" ]]; then
+		# Clear the waiting message so it doesn't overlap any following text.
+		printf "                                                                  \r" >&2
+	fi
+	unset waiting_message_displayed
+	# If the lock file is acquired, make sure that it is removed on exit.
+	trap _rmlock INT TERM EXIT
 }
 
 # This function is always run in a subshell. Running the function in a subshell
 # is required to make sure any lock directory is cleaned up by the exit trap in
 # _wait_for_lock.
-function upgrade_flutter () (
-  mkdir -p "$FLUTTER_ROOT/bin/cache"
-
-  local revision="$(cd "$FLUTTER_ROOT"; git rev-parse HEAD)"
-  local compilekey="$revision:$FLUTTER_TOOL_ARGS"
-
-  # Invalidate cache if:
-  #  * SNAPSHOT_PATH is not a file, or
-  #  * STAMP_PATH is not a file, or
-  #  * STAMP_PATH is an empty file, or
-  #  * Contents of STAMP_PATH is not what we are going to compile, or
-  #  * pubspec.yaml last modified after pubspec.lock
-  if [[ ! -f "$SNAPSHOT_PATH" || \
-        ! -s "$STAMP_PATH" || \
-        "$(cat "$STAMP_PATH")" != "$compilekey" || \
-        "$FLUTTER_TOOLS_DIR/pubspec.yaml" -nt "$FLUTTER_TOOLS_DIR/pubspec.lock" ]]; then
-    # Waits for the update lock to be acquired. Placing this check inside the
-    # conditional allows the majority of flutter/dart installations to bypass
-    # the lock entirely, but as a result this required a second verification that
-    # the SDK is up to date.
-    _wait_for_lock
-
-    # A different shell process might have updated the tool/SDK.
-    if [[ -f "$SNAPSHOT_PATH" && -s "$STAMP_PATH" && "$(cat "$STAMP_PATH")" == "$compilekey" && "$FLUTTER_TOOLS_DIR/pubspec.yaml" -ot "$FLUTTER_TOOLS_DIR/pubspec.lock" ]]; then
-      exit $?
-    fi
-
-    # Fetch Dart...
-    rm -f "$FLUTTER_ROOT/version"
-    rm -f "$FLUTTER_ROOT/bin/cache/flutter.version.json"
-    touch "$FLUTTER_ROOT/bin/cache/.dartignore"
-    "$FLUTTER_ROOT/bin/internal/update_dart_sdk.sh"
-
-    >&2 echo Building flutter tool...
-
-    # Prepare packages...
-    if [[ "$CI" == "true" || "$BOT" == "true" || "$CONTINUOUS_INTEGRATION" == "true" || "$CHROME_HEADLESS" == "1" ]]; then
-      PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_bot"
-    else
-      export PUB_SUMMARY_ONLY=1
-    fi
-    export PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_install"
-    pub_upgrade_with_retry
-
-    # Move the old snapshot - we can't just overwrite it as the VM might currently have it
-    # memory mapped (e.g. on flutter upgrade). For downloading a new dart sdk the folder is moved,
-    # so we take the same approach of moving the file here.
-    SNAPSHOT_PATH_OLD="$SNAPSHOT_PATH.old"
-    if [ -f "$SNAPSHOT_PATH" ]; then
-      mv "$SNAPSHOT_PATH" "$SNAPSHOT_PATH_OLD"
-    fi
-
-    # Compile...
-    "$DART" --verbosity=error --disable-dart-dev $FLUTTER_TOOL_ARGS --snapshot="$SNAPSHOT_PATH" --snapshot-kind="app-jit" --packages="$FLUTTER_TOOLS_DIR/.dart_tool/package_config.json" --no-enable-mirrors "$SCRIPT_PATH" > /dev/null
-    echo "$compilekey" > "$STAMP_PATH"
-
-    # Delete any temporary snapshot path.
-    if [ -f "$SNAPSHOT_PATH_OLD" ]; then
-      rm -f "$SNAPSHOT_PATH_OLD"
-    fi
-  fi
-  # The exit here is extraneous since the function is run in a subshell, but
-  # this serves as documentation that running the function in a subshell is
-  # required to make sure any lock directory created by mkdir is cleaned up.
-  exit $?
+function upgrade_flutter() (
+	mkdir -p "$FLUTTER_ROOT/bin/cache"
+
+	local revision="$(
+		cd "$FLUTTER_ROOT"
+		git rev-parse HEAD
+	)"
+	local compilekey="$revision:$FLUTTER_TOOL_ARGS"
+
+	# Invalidate cache if:
+	#  * SNAPSHOT_PATH is not a file, or
+	#  * STAMP_PATH is not a file, or
+	#  * STAMP_PATH is an empty file, or
+	#  * Contents of STAMP_PATH is not what we are going to compile, or
+	#  * pubspec.yaml last modified after pubspec.lock
+	if [[ ! -f "$SNAPSHOT_PATH" ||
+		! -s "$STAMP_PATH" ||
+		"$(cat "$STAMP_PATH")" != "$compilekey" ||
+		"$FLUTTER_TOOLS_DIR/pubspec.yaml" -nt "$FLUTTER_TOOLS_DIR/pubspec.lock" ]]; then
+		# Waits for the update lock to be acquired. Placing this check inside the
+		# conditional allows the majority of flutter/dart installations to bypass
+		# the lock entirely, but as a result this required a second verification that
+		# the SDK is up to date.
+		_wait_for_lock
+
+		# A different shell process might have updated the tool/SDK.
+		if [[ -f "$SNAPSHOT_PATH" && -s "$STAMP_PATH" && "$(cat "$STAMP_PATH")" == "$compilekey" && "$FLUTTER_TOOLS_DIR/pubspec.yaml" -ot "$FLUTTER_TOOLS_DIR/pubspec.lock" ]]; then
+			exit $?
+		fi
+
+		# Fetch Dart...
+		rm -f "$FLUTTER_ROOT/version"
+		rm -f "$FLUTTER_ROOT/bin/cache/flutter.version.json"
+		touch "$FLUTTER_ROOT/bin/cache/.dartignore"
+		"$FLUTTER_ROOT/bin/internal/update_dart_sdk.sh"
+
+		echo >&2 Building flutter tool...
+
+		# Prepare packages...
+		if [[ "$CI" == "true" || "$BOT" == "true" || "$CONTINUOUS_INTEGRATION" == "true" || "$CHROME_HEADLESS" == "1" ]]; then
+			PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_bot"
+		else
+			export PUB_SUMMARY_ONLY=1
+		fi
+		export PUB_ENVIRONMENT="$PUB_ENVIRONMENT:flutter_install"
+		pub_upgrade_with_retry
+
+		# Move the old snapshot - we can't just overwrite it as the VM might currently have it
+		# memory mapped (e.g. on flutter upgrade). For downloading a new dart sdk the folder is moved,
+		# so we take the same approach of moving the file here.
+		SNAPSHOT_PATH_OLD="$SNAPSHOT_PATH.old"
+		if [ -f "$SNAPSHOT_PATH" ]; then
+			mv "$SNAPSHOT_PATH" "$SNAPSHOT_PATH_OLD"
+		fi
+
+		# Compile...
+		"$DART" --verbosity=error --disable-dart-dev $FLUTTER_TOOL_ARGS --snapshot="$SNAPSHOT_PATH" --snapshot-kind="app-jit" --packages="$FLUTTER_TOOLS_DIR/.dart_tool/package_config.json" --no-enable-mirrors "$SCRIPT_PATH" >/dev/null
+		echo "$compilekey" >"$STAMP_PATH"
+
+		# Delete any temporary snapshot path.
+		if [ -f "$SNAPSHOT_PATH_OLD" ]; then
+			rm -f "$SNAPSHOT_PATH_OLD"
+		fi
+	fi
+	# The exit here is extraneous since the function is run in a subshell, but
+	# this serves as documentation that running the function in a subshell is
+	# required to make sure any lock directory created by mkdir is cleaned up.
+	exit $?
 )
 
 # This function is intended to be executed by entrypoints (e.g. `//bin/flutter`
 # and `//bin/dart`). PROG_NAME and BIN_DIR should already be set by those
 # entrypoints.
 function shared::execute() {
-  export FLUTTER_ROOT="$(cd "${BIN_DIR}/.." ; pwd -P)"
-
-  # If present, run the bootstrap script first
-  BOOTSTRAP_PATH="$FLUTTER_ROOT/bin/internal/bootstrap.sh"
-  if [ -f "$BOOTSTRAP_PATH" ]; then
-    source "$BOOTSTRAP_PATH"
-  fi
-
-  FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"
-  SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"
-  STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"
-  SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"
-  DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"
-
-  DART="$DART_SDK_PATH/bin/dart"
-
-  # If running over git-bash, overrides the default UNIX executables with win32
-  # executables
-  case "$(uname -s)" in
-    MINGW* | MSYS* )
-      DART="$DART.exe"
-      ;;
-  esac
-
-  # Test if running as superuser – but don't warn if running within Docker or CI.
-  if [[ "$EUID" == "0" && ! -f /.dockerenv && "$CI" != "true" && "$BOT" != "true" && "$CONTINUOUS_INTEGRATION" != "true" ]]; then
-    >&2 echo "   Woah! You appear to be trying to run flutter as root."
-    >&2 echo "   We strongly recommend running the flutter tool without superuser privileges."
-    >&2 echo "  /"
-    >&2 echo "📎"
-  fi
-
-  # Test if Git is available on the Host
-  if ! hash git 2>/dev/null; then
-    >&2 echo "Error: Unable to find git in your PATH."
-    exit 1
-  fi
-  # Test if the flutter directory is a git clone (otherwise git rev-parse HEAD
-  # would fail)
-  if [[ ! -e "$FLUTTER_ROOT/.git" ]]; then
-    >&2 echo "Error: The Flutter directory is not a clone of the GitHub project."
-    >&2 echo "       The flutter tool requires Git in order to operate properly;"
-    >&2 echo "       to install Flutter, see the instructions at:"
-    >&2 echo "       https://flutter.dev/get-started"
-    exit 1
-  fi
-
-  upgrade_flutter 7< "$PROG_NAME"
-
-  BIN_NAME="$(basename "$PROG_NAME")"
-  case "$BIN_NAME" in
-    flutter*)
-      # FLUTTER_TOOL_ARGS aren't quoted below, because it is meant to be
-      # considered as separate space-separated args.
-      exec "$DART" --disable-dart-dev --packages="$FLUTTER_TOOLS_DIR/.dart_tool/package_config.json" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@"
-      ;;
-    dart*)
-      exec "$DART" "$@"
-      ;;
-    *)
-      >&2 echo "Error! Executable name $BIN_NAME not recognized!"
-      exit 1
-      ;;
-  esac
+	export FLUTTER_ROOT="$(
+		cd "${BIN_DIR}/.."
+		pwd -P
+	)"
+
+	# If present, run the bootstrap script first
+	BOOTSTRAP_PATH="$FLUTTER_ROOT/bin/internal/bootstrap.sh"
+	if [ -f "$BOOTSTRAP_PATH" ]; then
+		source "$BOOTSTRAP_PATH"
+	fi
+
+	FLUTTER_TOOLS_DIR="$FLUTTER_ROOT/packages/flutter_tools"
+	SNAPSHOT_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.snapshot"
+	STAMP_PATH="$FLUTTER_ROOT/bin/cache/flutter_tools.stamp"
+	SCRIPT_PATH="$FLUTTER_TOOLS_DIR/bin/flutter_tools.dart"
+	DART_SDK_PATH="$FLUTTER_ROOT/bin/cache/dart-sdk"
+
+	DART="$DART_SDK_PATH/bin/dart"
+
+	# If running over git-bash, overrides the default UNIX executables with win32
+	# executables
+	case "$(uname -s)" in
+	MINGW* | MSYS*)
+		DART="$DART.exe"
+		;;
+	esac
+
+	# Test if running as superuser – but don't warn if running within Docker or CI.
+	if [[ "$EUID" == "0" && ! -f /.dockerenv && "$CI" != "true" && "$BOT" != "true" && "$CONTINUOUS_INTEGRATION" != "true" ]]; then
+		echo >&2 "   Woah! You appear to be trying to run flutter as root."
+		echo >&2 "   We strongly recommend running the flutter tool without superuser privileges."
+		echo >&2 "  /"
+		echo >&2 "📎"
+	fi
+
+	upgrade_flutter 7<"$PROG_NAME"
+
+	BIN_NAME="$(basename "$PROG_NAME")"
+	case "$BIN_NAME" in
+	flutter*)
+		# FLUTTER_TOOL_ARGS aren't quoted below, because it is meant to be
+		# considered as separate space-separated args.
+		exec "$DART" --disable-dart-dev --packages="$FLUTTER_TOOLS_DIR/.dart_tool/package_config.json" $FLUTTER_TOOL_ARGS "$SNAPSHOT_PATH" "$@"
+		;;
+	dart*)
+		exec "$DART" "$@"
+		;;
+	*)
+		echo >&2 "Error! Executable name $BIN_NAME not recognized!"
+		exit 1
+		;;
+	esac
 }
diff --git a/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart b/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart
index 5d6d78639f..90a4dfa555 100644
--- a/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart
+++ b/packages/flutter_tools/lib/src/runner/flutter_command_runner.dart
@@ -297,7 +297,6 @@ class FlutterCommandRunner extends CommandRunner<void> {
           globals.flutterUsage.suppressAnalytics = true;
         }
 
-        globals.flutterVersion.ensureVersionFile();
         final bool machineFlag = topLevelResults[FlutterGlobalOptions.kMachineFlag] as bool? ?? false;
         final bool ci = await globals.botDetector.isRunningOnBot;
         final bool redirectedCompletion = !globals.stdio.hasTerminal &&
@@ -306,11 +305,6 @@ class FlutterCommandRunner extends CommandRunner<void> {
         final bool versionCheckFlag = topLevelResults[FlutterGlobalOptions.kVersionCheckFlag] as bool? ?? false;
         final bool explicitVersionCheckPassed = topLevelResults.wasParsed(FlutterGlobalOptions.kVersionCheckFlag) && versionCheckFlag;
 
-        if (topLevelResults.command?.name != 'upgrade' &&
-            (explicitVersionCheckPassed || (versionCheckFlag && !isMachine))) {
-          await globals.flutterVersion.checkFlutterVersionFreshness();
-        }
-
         // See if the user specified a specific device.
         final String? specifiedDeviceId = topLevelResults[FlutterGlobalOptions.kDeviceIdOption] as String?;
         if (specifiedDeviceId != null) {
